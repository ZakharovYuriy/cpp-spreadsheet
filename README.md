# cpp-spreadsheet
Дипломный проект: Электронная таблица

Читать на других языках: [English](README.md), [Русский](README.RUS.md)

# Описание программы
«Электронная таблица»‎ это упрощённый аналог существующих решений: лист таблицы Microsoft Excel или Google Sheets. В ячейках таблицы могут быть текст или формулы. Формулы, как и в существующих решениях, могут содержать индексы ячеек.

# Сборка при помощи Cmake
To build this project on linux you need:<br>
1)If you don't have Cmake installed, install Cmake<br>
2)

2)If the "Debug" or "Release" folders are not created:<br>

```
mkdir ../Debug
mkdir ../Release
```
3)Go to the `transport-catalog` folder and run the command for Debug and/or Release conf:<br>
:exclamation: :exclamation: :exclamation:<br>
Change `/path/to/protobuf/package` to the path to the protobuf you installed in the previous steps<br>

```
cmake -E chdir ../Debug/ cmake -G "Unix Makefiles" ../spreadsheet/ -DCMAKE_BUILD_TYPE:STRING=Debug
cmake -E chdir ../Release/ cmake -G "Unix Makefiles" ../spreadsheet/ -DCMAKE_BUILD_TYPE:STRING=Release 
```
4)Go to "Debug" or "Release" folder and build:<br>

```
cmake --build .
```
**ALL in one command(Release)**:<br>

```
mkdir Release; cmake -E chdir Release/ cmake -G "Unix Makefiles" ../ -DCMAKE_BUILD_TYPE:STRING=Release && cmake --build Release/.
```

5)To **Run** program - in the debug or release folder run:<br>

```
./spreadsheet
```

# Использование

### Перед тем как начать:
  0. Установка и настройкка всех требуемых компонентов в среде разработки длля запуска приложения
  1. Вариант использования показан в main.cpp и при вызове `./transport_catalogue -help`
  2. Примеры входных документов и ответы на них есть в папке `Examples`.

## Описание возможностей:
Ячейка таблицы задаётся своим индексом, то есть строкой вида “А1”, “С14” или “RD2”. Причём ячейка с индексом “А1” — это ячейка в левом верхнем углу таблицы. Количество строк и столбцов в таблице не превышает 16384. То есть предельная позиция ячейки — (16383, 16383) с индексом** “XFD16384”. Если позиция ячейки выходит за эти границы, то она не валидна по определению.

Структура  Position в файле common.h. Она содержит поля introw и int col — номера строки и столбца ячейки в программном представлении. Используется для доступа к ячейкам.

Используем абстрактное синтаксическое дерево, или AST, с которым вы уже работали в уроках по Mython.
Абстрактное синтаксическое дерево не умеет ничего вычислять, но мы «научим»‎ его, задав новый функционал.

Этапы вычисления
Мы помним, что формула состоит из операндов и операций**. Чтобы вычислить её, нужно знать:
Какие бывают операции и операнды:
операции могут быть арифметическими (+, -, *, /), логическими (&, |, ⇒, ~);
операнды могут быть числами (1, 5, 1000.01), булевыми переменными (TRUE, FALSE), константами (π, e, g, ν).

(abstract syntax tree, AST).
Для абстрактного синтаксического дерева мы можем сами определить классы-узлы и добавить в них метод для вычисления. Назовём его, например, GetValue().

ANTLR — это специальная программа, которая сгенерирует для нас код лексического и синтаксического анализаторов, а также код для обхода дерева разбора на С++.




Индексы
Пользователь имеет доступ к ячейке по индексу, то есть по строке вида “А1” или “RD2”. Функции для конвертации: Position::FromString() и Position::ToString().

Минимальная печатная область
Чтобы напечатать таблицу, нужно знать размер минимальной печатной области. Это минимальная прямоугольная область с вершиной в ячейке A1, содержащая все непустые ячейки.
Структура Size определена в файле common.h. Она содержит количество строк и столбцов в минимальной печатной области.

Методы, обращающиеся к ячейке по индексу:
 - SetCell(Position, std::string) задаёт содержимое ячейки по индексу Position. Если ячейка пуста, надо её создать. Нужно задать ячейке текст методом Cell::Set(std::string);
 - Cell* GetCell(Position pos) константный и неконстантный геттеры, которые возвращают указатель на ячейку, расположенную по индексу pos. Если ячейка пуста, возвращают nullptr;
 - void ClearCell(Position pos) очищает ячейку по индексу. Последующий вызов GetCell() для этой ячейки вернёт nullptr. При этом может измениться размер минимальной печатной области.

Методы, применимые к таблице целиком:
 - Size GetPrintableSize() определяет размер минимальной печатной области. Специально для него в файле common.h и определена структура Size. Она содержит количество строк и столбцов в минимальной печатной области.
 - Печать таблицы выводит в стандартный поток вывода std::ostream& минимальную прямоугольную печатную область. Ячейки из одной строки разделены табуляцией \t, в конце строки ставится символ перевода строки \n.
 - void PrintText(std::ostream&) выводит текстовые представления ячеек:
для текстовых ячеек это текст, который пользователь задал в методе Set(), то есть не очищенный от ведущих апострофов ';
для формульных это формула, очищенная от лишних скобок, как Formula::GetExpression(), но с ведущим знаком “=”.
 - void PrintValues(std::ostream&) выводит значения ячеек — строки, числа или FormulaError, — как это определено в Cells::GetValue(). 

Вычисление значений в ячейках
Рассмотрим пример. В ячейке С2 записана формула “=A3/A2”. Чтобы её вычислить, надо разделить значение ячейки А3 на значение ячейки А2.
В ячейке А3 находится формула “=1+2*7”. Её легко вычислить: это 15.
В ячейке A2 находится текст “3”. Формально ячейка не формульная. Но её текст можно интерпретировать как число. Поэтому предполагаем, что её значение 3.
Результат 15/3=5.
Если формула содержит индекс пустой ячейки, предполагаем, что значение пустой ячейки — 0.

Ошибки вычисления
В вычислениях могут возникнуть ошибки. Например, «‎деление на 0»‎. Если делитель равен 0, значение ячейки — ошибка FormulaError типа #DIV/0!

Если ячейку, чей индекс входит в формулу, нельзя проинтерпретировать как число, возникает ошибка типа: FormulaError — нет значения #VALUE! 

Формула может содержать ссылку на ячейку, которая выходит за границы возможного размера таблицы, например С2 (=А1234567+ZZZZ1). Такая формула может быть создана, но не может быть вычислена, поэтому её вычисление вернёт ошибку #REF!

Ошибки распространяются вверх по зависимостям. Например: формула в С4 зависит от С2 (=С2+8). Формула в С2 выдала ошибку вычисления #VALUE! Значит, формула в С4 выдаст ту же ошибку при вычислении.

Точно так же распространяются ошибки #DIV/0! и #REF! Если формула зависит от нескольких ячеек, каждая из которых содержит ошибку вычисления, результирующая ошибка может соответствовать любой из них.

Циклические зависимости
Таблица должна всегда оставаться корректной. Если ячейки циклически зависят друг от друга, мы не сможем вычислить значения ячеек. Поэтому нельзя позволить, чтобы возникли циклические зависимости между ячейками. То есть нельзя задать ячейку с формулой, которая вводит циклические зависимости. Программа выдаст исключение CircularDependencyException, а ячейка не изменится.


Возможные ошибки и исключения
 - Некорректная формула. Если в ячейку методомSheet::SetCell() пытаются записать синтаксически некорректную формулу, например =A1+*, реализация выбросит исключение FormulaException, а значение ячейки не изменится. Формула считается синтаксически некорректной, если она не удовлетворяет предоставленной грамматике.
 - Некорректная позиция. Программно возможно создать экземпляр класса Position c некорректной позицией, например (-1, -1). Если пользователь передаёт её в методы, программа выдаст исключение InvalidPositionException. Методы интерфейсов — например Cell::GetReferencedCells() — всегда возвращает корректные позиции.
 - Циклическая зависимость. Если пользователь пытается в методе Sheet::SetCell() записать в ячейку формулу, которая привела бы к циклической зависимости, реализация выбросит исключение CircularDependencyException, а значение ячейки не изменится.

# Системые требования:
  1. C++17(STL)
  2. GCC (MinG w64) 11.2.0  
  
# Паны по доработке:
1. Добавить UI
2. Заменить библиотеку поиска маршрута
3. Добавить возможность предложения нескольких путей на выбор

# Стек технологий:
  1. Хеш-функции, **unordered_map** и **unordered_set**
  2. Деревья
  3. **namespases**
  4. JSON
  5. Умные указатели **unique_ptr**, **shared_ptr** и **weak_ptr**
  6. Наследование и полиморфизм, абстрактные классы, интерфейсы
  7. Runtime-полиморфизм с std::variant, динамическое приведение типов
  8. Immediately invoked lambda expression, **std::invoke**
  9. **mutable**
 10. Работа с путями и потоками: ввода/вывода, строковыми, для работы с файлами
 11. Регулярноые выражения **std::regex**
 12. RAII - "Resource Acquisition is Initialization”
 13. **move**-семантика, Forwarding reference
 14. Плотная упаковка, сериализация, десериализация, Google Protocol Buffers - Protobuf
 15. Таблица виртуальных методов

# Структура
### Описание файлов программы

# Формат входных данных




